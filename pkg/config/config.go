package config

import (
	"fmt"
	"os"

	"github.com/BurntSushi/toml"
)

// Package represents a Droy package configuration
type Package struct {
	Name            string            `toml:"name"`
	Version         string            `toml:"version"`
	Description     string            `toml:"description,omitempty"`
	Author          string            `toml:"author,omitempty"`
	License         string            `toml:"license,omitempty"`
	Repository      string            `toml:"repository,omitempty"`
	Homepage        string            `toml:"homepage,omitempty"`
	Keywords        []string          `toml:"keywords,omitempty"`
	DroyVersion     string            `toml:"droy_version,omitempty"`
	Main            string            `toml:"main,omitempty"`
	Bin             map[string]string `toml:"bin,omitempty"`
	Scripts         map[string]string `toml:"scripts,omitempty"`
	Dependencies    map[string]string `toml:"dependencies,omitempty"`
	DevDependencies map[string]string `toml:"devDependencies,omitempty"`
	PeerDependencies map[string]string `toml:"peerDependencies,omitempty"`
	Engines         map[string]string `toml:"engines,omitempty"`
	OS              []string          `toml:"os,omitempty"`
	CPU             []string          `toml:"cpu,omitempty"`
	Private         bool              `toml:"private,omitempty"`
	PublishConfig   *PublishConfig    `toml:"publishConfig,omitempty"`
}

// PublishConfig contains publishing configuration
type PublishConfig struct {
	Registry    string `toml:"registry,omitempty"`
	Access      string `toml:"access,omitempty"`
	Tag         string `toml:"tag,omitempty"`
}

// LockFile represents the lock file structure
type LockFile struct {
	Version      string            `toml:"version"`
	LockfileVersion int           `toml:"lockfileVersion"`
	Dependencies map[string]string `toml:"dependencies"`
	Packages     map[string]*LockPackage `toml:"packages,omitempty"`
}

// LockPackage represents a locked package
type LockPackage struct {
	Version      string            `toml:"version"`
	Resolved     string            `toml:"resolved"`
	Integrity    string            `toml:"integrity,omitempty"`
	Dependencies map[string]string `toml:"dependencies,omitempty"`
}

// ReadPackageConfig reads a package configuration from a TOML file
func ReadPackageConfig(path string) (*Package, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	var pkg Package
	if err := toml.Unmarshal(data, &pkg); err != nil {
		return nil, fmt.Errorf("failed to parse TOML: %w", err)
	}

	// Initialize maps if nil
	if pkg.Dependencies == nil {
		pkg.Dependencies = make(map[string]string)
	}
	if pkg.DevDependencies == nil {
		pkg.DevDependencies = make(map[string]string)
	}
	if pkg.PeerDependencies == nil {
		pkg.PeerDependencies = make(map[string]string)
	}
	if pkg.Scripts == nil {
		pkg.Scripts = make(map[string]string)
	}
	if pkg.Bin == nil {
		pkg.Bin = make(map[string]string)
	}

	return &pkg, nil
}

// WritePackageConfig writes a package configuration to a TOML file
func WritePackageConfig(pkg *Package, path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Write header comment
	fmt.Fprintln(file, "# Droy Package Configuration")
	fmt.Fprintln(file, "# Generated by droy-pm")
	fmt.Fprintln(file, "# https://github.com/droy-go/droy-lang")
	fmt.Fprintln(file)

	encoder := toml.NewEncoder(file)
	if err := encoder.Encode(pkg); err != nil {
		return fmt.Errorf("failed to encode TOML: %w", err)
	}

	return nil
}

// ReadLockFile reads a lock file
func ReadLockFile(path string) (*LockFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	var lock LockFile
	if err := toml.Unmarshal(data, &lock); err != nil {
		return nil, fmt.Errorf("failed to parse TOML: %w", err)
	}

	if lock.Dependencies == nil {
		lock.Dependencies = make(map[string]string)
	}
	if lock.Packages == nil {
		lock.Packages = make(map[string]*LockPackage)
	}

	return &lock, nil
}

// WriteLockFile writes a lock file
func WriteLockFile(lock *LockFile, path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer file.Close()

	// Write header comment
	fmt.Fprintln(file, "# Droy Lock File")
	fmt.Fprintln(file, "# This file is auto-generated. Do not edit manually.")
	fmt.Fprintln(file)

	encoder := toml.NewEncoder(file)
	if err := encoder.Encode(lock); err != nil {
		return fmt.Errorf("failed to encode TOML: %w", err)
	}

	return nil
}

// AddDependency adds a dependency to the package
func (p *Package) AddDependency(name, version string, dev bool) {
	if dev {
		if p.DevDependencies == nil {
			p.DevDependencies = make(map[string]string)
		}
		p.DevDependencies[name] = version
	} else {
		if p.Dependencies == nil {
			p.Dependencies = make(map[string]string)
		}
		p.Dependencies[name] = version
	}
}

// RemoveDependency removes a dependency from the package
func (p *Package) RemoveDependency(name string) {
	delete(p.Dependencies, name)
	delete(p.DevDependencies, name)
	delete(p.PeerDependencies, name)
}

// HasDependency checks if a dependency exists
func (p *Package) HasDependency(name string) bool {
	_, hasProd := p.Dependencies[name]
	_, hasDev := p.DevDependencies[name]
	_, hasPeer := p.PeerDependencies[name]
	return hasProd || hasDev || hasPeer
}

// GetDependencyVersion gets the version of a dependency
func (p *Package) GetDependencyVersion(name string) (string, bool) {
	if v, ok := p.Dependencies[name]; ok {
		return v, true
	}
	if v, ok := p.DevDependencies[name]; ok {
		return v, true
	}
	if v, ok := p.PeerDependencies[name]; ok {
		return v, true
	}
	return "", false
}
